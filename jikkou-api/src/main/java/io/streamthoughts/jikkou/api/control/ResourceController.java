/*
 * Copyright 2022 StreamThoughts.
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.streamthoughts.jikkou.api.control;

import io.streamthoughts.jikkou.api.ReconciliationCallable;
import io.streamthoughts.jikkou.api.ReconciliationContext;
import io.streamthoughts.jikkou.api.ReconciliationMode;
import io.streamthoughts.jikkou.api.extensions.Extension;
import io.streamthoughts.jikkou.api.extensions.annotations.ExtensionType;
import io.streamthoughts.jikkou.api.model.HasMetadata;
import io.streamthoughts.jikkou.api.model.HasMetadataAcceptable;
import io.streamthoughts.jikkou.common.annotation.InterfaceStability;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import org.jetbrains.annotations.NotNull;

/**
 * The top-level interface for managing resources that live on a kafka cluster, e.g., Topics, Quotas, ACLs.
 *
 * @param <R> type of the {@link HasMetadata} handle by this controller.
 * @param <C> type of {@link Change} to be generated by the manager.
 */
@InterfaceStability.Evolving
@ExtensionType("controller")
public interface ResourceController<
        R extends HasMetadata,
        C extends Change<?>>
        extends ResourceDescriptor<R>, HasMetadataAcceptable, Extension, AutoCloseable {

    ReconciliationConfig defaultConciliationConfig();

    default ReconciliationCallable getReconciliationTask(@NotNull final HasMetadata resource,
                                                         @NotNull final ReconciliationMode reconciliationMode,
                                                         @NotNull final ReconciliationContext reconciliationContext) {
        return new ReconciliationCallable() {
            @Override
            public Collection<ChangeResult<?>> call() {

                @SuppressWarnings("unchecked")
                R typedResource = (R) resource;

                List<C> changes = computeReconciliationChanges(typedResource, reconciliationContext);

                return new LinkedList<>(switch (reconciliationMode) {
                    case CREATE_ONLY -> create(changes, reconciliationContext.isDryRun());
                    case DELETE_ONLY -> delete(changes, reconciliationContext.isDryRun());
                    case UPDATE_ONLY -> update(changes, reconciliationContext.isDryRun());
                    case APPLY_ALL -> apply(changes, reconciliationContext.isDryRun());
                });
            }

            @Override
            public HasMetadata resource() {
                return resource;
            }
        };
    }

    /**
     * Computes all the changes to be applied to reconcile the specified resource.
     *
     * @param resource         the resource to be reconciled.
     * @param reconciliationContext the operation context.
     * @return the list of changes.
     */
    List<C> computeReconciliationChanges(@NotNull R resource,
                                         @NotNull ReconciliationContext reconciliationContext);

    /**
     * This method will apply all or part of the specified changes to create new resource objects.
     *
     * @param changes the list of changes that will be applied eventually.
     * @param dryRun  specify whether this operation should be executed in dry-run.
     * @return the list of all changes applied.
     */
    Collection<ChangeResult<C>> create(@NotNull List<C> changes, boolean dryRun);

    /**
     * This method will apply all or part of the specified changes to update existing resource objects.
     *
     * @param changes the list of changes that will be applied eventually.
     * @param dryRun  specify whether this operation should be executed in dry-run.
     * @return the list of all changes applied.
     */
    Collection<ChangeResult<C>> update(@NotNull List<C> changes, boolean dryRun);

    /**
     * This method will apply all or part of the specified changes to delete resource objects.
     *
     * @param changes the list of changes that will be applied eventually.
     * @param dryRun  specify whether this operation should be executed in dry-run.
     * @return the list of all changes applied.
     */
    Collection<ChangeResult<C>> delete(@NotNull List<C> changes, boolean dryRun);

    /**
     * @param changes the list of changes that will be applied eventually.
     * @param dryRun  specify whether this operation should be executed in dry-run.
     * @return the list of all changes applied.
     */
    Collection<ChangeResult<C>> apply(@NotNull List<C> changes, boolean dryRun);

    /**
     * {@inheritDoc}
     */
    @Override
    default void close() {}

}
